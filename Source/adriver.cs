//#define OTHER_TEST
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using Microsoft.CSharp;

namespace NSCs_codegen {
    public partial class cs_codegenDriver {
        [STAThread()]
        public static void Main(string[] args) {
            int exitCode = 0;
            SqlConnectionStringBuilder sb = new SqlConnectionStringBuilder();
            TextWriterTraceListener twtl = null;
            string connStr, logFile, dir, appName, nameSpace, server, database;
            const string TRACER_NAME = "blah";
            CodeDomProvider cdp = new CSharpCodeProvider();
            CodeGeneratorOptions opts = new CodeGeneratorOptions();
            string outDir;
            List<string> argsToProcess;
            bool showHelp;


            opts.BlankLinesBetweenMembers = false;
            opts.ElseOnClosing = true;

            appName = Assembly.GetEntryAssembly().GetName().Name;
#if TRACE
            logFile = Environment.ExpandEnvironmentVariables("%TEMP%" + "\\" + appName + "\\" + appName + ".log");
            if (!Directory.Exists(dir = Path.GetDirectoryName(logFile)))
                Directory.CreateDirectory(dir);

            twtl = new TextWriterTraceListener(logFile, TRACER_NAME);
            Trace.Listeners.Add(twtl);
#endif
            Trace.WriteLine(appName + " starts");

            argsToProcess = parseArguments(args, out nameSpace, out server, out database, out showHelp, out outDir);
            if (string.IsNullOrEmpty(database)) {
                Console.Error.WriteLine("database not specified.  Cannot continue.");
                showHelp = true;
            }
            if (string.IsNullOrEmpty(outDir)) {
                Console.Error.WriteLine("output-directory not specified.  Cannot continue.");
                showHelp = true;
            }
            if (showHelp) {
                Console.Error.WriteLine("show help here");
                exitCode = 2;
            } else {

                sb = new SqlConnectionStringBuilder();
                sb.ApplicationName = appName;
                sb.DataSource = server;
                sb.InitialCatalog = database;
                //      sb.InitialCatalog = "QualityAndEngineering";
#if false
            sb.IntegratedSecurity = false;
            sb.UserID = "operator";
            sb.Password = "operator";
#else
                sb.IntegratedSecurity = true;
#endif
                connStr = sb.ConnectionString;

                Trace.WriteLine("ConnectionString is " + (connStr = sb.ConnectionString));

                Trace.WriteLine("Generate files in: " + outDir);
                //''        outDir = Path.Combine(Directory.GetCurrentDirectory(), "Generated_Files", sb.InitialCatalog);
                try {
                    if (!Directory.Exists(outDir))
                        Directory.CreateDirectory(outDir);
                    using (SqlConnection conn = new SqlConnection(connStr)) {
                        conn.InfoMessage += Conn_InfoMessage;
                        conn.Open();
#if OTHER_TEST
                    invokeTestProc(conn);
#else

                        //                    generateCodeForSingleTable(conn, "colt_employee", outDir, string.Empty, cdp, opts);
                        //                    generateCodeForSingleTable(conn, "query", outDir, string.Empty, cdp, opts);
                        generateCodeFromTables(conn, outDir, nameSpace, cdp, opts);
                        //                    generateCodeFromViews(conn, outDir, string.Empty, cdp, opts);
                        //                    generateCodeFromTables(conn, "KanbanTemp_CreateKanbanFile", Directory.GetCurrentDirectory(), string.Empty, cdp, opts);
#endif
                        conn.Close();
                    }
                } catch (Exception ex) {
                    Trace.WriteLine(ex.Message);
                } finally {

                }
            }
            Trace.WriteLine(appName + " ends");
#if TRACE
            Trace.Flush();
            if (twtl != null)
                Trace.Listeners.Remove(TRACER_NAME);
#endif
            Environment.Exit(exitCode);
        }

        /// <summary>parse the command-line parameters.</summary>
        /// <param name="args"></param>
        /// <param name="nameSpace"></param>
        /// <param name="server"></param>
        /// <param name="database"></param>
        /// <param name="showHelp"></param>
        /// <param name="outDir"></param>
        /// <returns></returns>
        static List<string> parseArguments(string[] args, out string nameSpace, out string server, out string database, out bool showHelp, out string outDir) {
            List<string> argsToProcess=new List<string>();
            int nargs = args.Length, len;
            string anArg;

            nameSpace = "Colt.Database";
            server = "colt-sql";
            outDir = null;
            database = null;
//            database = "checkweigh_data_dev";

            //        zipName = null;
            showHelp = false;
            argsToProcess = new List<string>();
            for (int i = 0; i < nargs; i++) {
                anArg = args[i];
                if ((len = anArg.Length) >= 2) {
                    if (anArg[0] == '-' || anArg[0] == '/') {
                        switch (anArg[1]) {
                            case 'd':
                                if (len > 2)
                                    database = anArg.Substring(2).Trim();
                                else { database = args[i + 1]; i++; }
                                break;
                            case 'n':
                                if (len > 2)
                                    nameSpace = anArg.Substring(2).Trim();
                                else { nameSpace = args[i + 1]; i++; }
                                break;
                            case 'o':
                                if (len > 2)
                                    outDir = anArg.Substring(2).Trim();
                                else { outDir = args[i + 1]; i++; }
                                break;
                            case 's':
                                if (len > 2)
                                    server = anArg.Substring(2).Trim();
                                else { server = args[i + 1]; i++; }
                                break;
                            case 'h': showHelp = true; break;
                            case '?': showHelp = true; break;
                        }
                    } else {
                        argsToProcess.Add(anArg);
                    }
                }
            }
            return argsToProcess;
        }


        static void generateCodeFromViews(SqlConnection conn, string outDir, string nameSpace, CodeDomProvider cdp, CodeGeneratorOptions opts) {
            generateCodeSysObjectType(conn, outDir, nameSpace, cdp, opts, "V");
        }

        static void generateCodeFromTables(SqlConnection conn, string outDir, string nameSpace, CodeDomProvider cdp, CodeGeneratorOptions opts) {
            generateCodeSysObjectType(conn, outDir, nameSpace, cdp, opts, "U");
        }

        static void generateCodeSysObjectType(SqlConnection conn, string outDir, string nameSpace, CodeDomProvider cdp, CodeGeneratorOptions opts, string objType) {
            List<string> names = new List<string>();

            SqlDataReader reader;
            try {
                if (conn.State != ConnectionState.Open)
                    conn.Open();
                using (SqlCommand cmd = new SqlCommand("select name from sysobjects where type='" + objType + "' and uid=user_id('DBO') order by name", conn)) {
                    reader = cmd.ExecuteReader();
                    while (reader.Read())
                        names.Add(reader.GetString(0));
                    reader.Close();
                }
                foreach (string aTable in names)
                    generateCodeForSingleTable(conn, aTable, outDir, nameSpace, cdp, opts);

                conn.Close();
            } catch (Exception ex) {
                Logger.logMethod(MethodBase.GetCurrentMethod(), ex);
            }
        }

        static void generateCodeForSingleTable(SqlConnection conn, string aTable, string outDir, string nameSpace, CodeDomProvider cdp, CodeGeneratorOptions opts) {
            SqlDataReader reader;

            using (SqlCommand cmd = new SqlCommand("SELECT * FROM " + aTable + " WHERE 1=0", conn)) {
                if (conn.State != ConnectionState.Open)
                    conn.Open();
                //                cmd.CommandText = "SELECT * FROM " + aTable + " WHERE 1=0";
                reader = cmd.ExecuteReader();
                generateStuff(makeClassName(aTable), outDir, nameSpace, cdp, opts, reader, aTable);
                reader.Close();
            }
        }

        static void Conn_InfoMessage(object sender, SqlInfoMessageEventArgs e) {
            Logger.logMethod(MethodBase.GetCurrentMethod(), e.Message);
        }

        /*
        static void tryToReceiveData(SqlCommand cmd) {
            SqlDataReader reader;
            int nrows = 0;

            reader = cmd.ExecuteReader();
            while (reader.Read())
                nrows++;

            Trace.WriteLine("read " + nrows + " of data!");
        }
        */


#if false
        using System.Data.SqlClient;

namespace NSSnertPop {
    class AllocInfo {
        #region ctor
        public AllocInfo(SqlDataReader reader) {
            string colName;

            for (int i = 0; i < reader.FieldCount; i++) {
                switch (colName = reader.GetName(i)) {
                    case "lower_part_no": /* String */lowerPartNo = reader.GetString(i); break;
                    case "vendor_id": /* Int32 */vendorId = reader.GetInt32(i); break;
                    case "sn_length": /* Int32 */snLength = reader.GetInt32(i); break;
                    case "prefix": /* String */prefix = reader.GetString(i); break;
                    case "suffix": /* String */suffix = reader.IsDBNull(i) ? string.Empty : reader.GetString(i); break;
                    case "pattern_name": /* String */pattern = reader.IsDBNull(i) ? null : reader.GetString(i); break;
                    case "laser_job_no": /* String */laserJobNo = reader.IsDBNull(i) ? null : reader.GetString(i); break;
                    case "laser_flip": /* Boolean */laserFlip = reader.GetBoolean(i); break;
                    case "next_serial_number": /* Int32 */nextNum = reader.GetInt32(i); break;
                    case "weapon_type_id": /* Int32 */weaponTypeId = reader.GetInt32(i); break;
                }
            }
        }
        #endregion

        #region properties
        public int nextNum { get; private set; }
        public string prefix { get; private set; }
        public int snLength { get; private set; }
        public string suffix { get; private set; }
        public string lowerPartNo { get; private set; }
        public int vendorId { get; private set; }
        public string pattern { get; private set; }
        public string laserJobNo { get; private set; }
        public bool laserFlip { get; private set; }
        public int weaponTypeId { get; private set; }

        #endregion

        #region methods
        internal static AllocInfo fromReader(SqlDataReader reader) {
            return new AllocInfo(reader);
        }
        #endregion
    }
}
#endif
    }
}